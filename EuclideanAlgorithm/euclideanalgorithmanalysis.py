# -*- coding: utf-8 -*-
"""EuclideanAlgorithmAnalysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q7j7gcw0kRuGMLqj3A3CciK4OLU3tTBU

# Analysis of Java Algorithm
"""

# Referenced https://towardsdatascience.com/3-ways-to-load-csv-files-into-colab-7c14fcbdcb92
# Used to upload the data
from google.colab import files
uploaded = files.upload()

# Commented out IPython magic to ensure Python compatibility.
import csv
import sys
import time
import numpy as np
import matplotlib
# Allows plots to display in Google Colaboratory
# %matplotlib inline 
import matplotlib.pyplot as plt

# Referenced https://stackoverflow.com/questions/11351508/reading-in-csv-lines-and-creating-lists-for-each-line
reader = csv.reader(open('myfile.csv'))
lines = list(reader)

# Make the lists more understandable with names
# Test 1 = the recursive and iterative methods ran repeatedly in their own individual while loops
# Test 2 = the recursive method was followed by the iterative method in a single while loop that repeated
timesRecursive1: [float] = []
timesIterative1: [float] = []
timesRecursive2: [float] = []
timesIterative2: [float] = []
numbers: [int] = []

# UF = unfiltered
UFtimesRecursive1: [float] = []
UFtimesIterative1: [float] = []
UFtimesRecursive2: [float] = []
UFtimesIterative2: [float] = []

# Remove the last blank point, convert the strings to numbers, and clean up numbers overly big/small

floor: float = 1e-7
ceil: float = 1e-6

lines[0].remove('')
for value in lines[0]:
  floatvalue = float(value)
  UFtimesRecursive1.append(floatvalue)
  if (floatvalue >= floor and floatvalue <= ceil):
    timesRecursive1.append(floatvalue)
  elif (floatvalue > ceil):
    timesRecursive1.append(ceil)
  else:
    timesRecursive1.append(floor)


lines[1].remove('')
for value in lines[1]:
  floatvalue = float(value)
  UFtimesIterative1.append(floatvalue)
  if (floatvalue >= floor and floatvalue <= ceil):
    timesIterative1.append(floatvalue)
  elif (floatvalue > ceil):
    timesIterative1.append(ceil)
  else:
    timesIterative1.append(floor)


lines[2].remove('')
for value in lines[2]:
  floatvalue = float(value)
  UFtimesRecursive2.append(floatvalue)
  if (floatvalue >= floor and floatvalue <= ceil):
    timesRecursive2.append(floatvalue)
  elif (floatvalue > ceil):
    timesRecursive2.append(ceil)
  else:
    timesRecursive2.append(floor)

lines[3].remove('')
for value in lines[3]:
  floatvalue = float(value)
  UFtimesIterative2.append(floatvalue)
  if (floatvalue >= floor and floatvalue <= ceil):
    timesIterative2.append(floatvalue)
  elif (floatvalue > ceil):
    timesIterative2.append(ceil)
  else:
    timesIterative2.append(floor)

lines[4].remove('')
for value in lines[4]:
  numbers.append(float(value))

# num_trials is the number of trials that were run, i.e. the number of times each method was run in each test
num_trials = 100
num_ints = num_trials * 2
# Get an array of trial numbers for graphing
trial_number = []
for i in range(1, num_trials+1):
  trial_number.append(i)

# Test 1
# Determine figure size
plt.figure(figsize=(20,6))

# The first parameter of scatter is the x-axis
# The second parameter of scatter is the y-axis
# Then size for the dots, s; I've made the size of each dot proportional to the data point it represents,
# so it is easier to see any patterns just by looking
# Then color
# label specifies the label for that color on the legend
s = [10e7*n for n in timesRecursive1]
plt.scatter(trial_number, timesRecursive1, s=s, color='red',label='Recursive')
s = [10e7*n for n in timesIterative1]
plt.scatter(trial_number, timesIterative1, s=s, color='green',label='Iterative')

# Set a title for the plot
plt.title("Filtered Runtime of the Euclidean Algorithm Recursively vs. Iteratively in Different While Loops")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add labels to the x and y-axes
plt.xlabel('Trial Number')
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()

# Test 2
# Determine figure size
plt.figure(figsize=(20,6))

s = [10e7*n for n in timesRecursive2]
plt.scatter(trial_number, timesRecursive2, s=s, color='blue',label='Recursive')
s = [10e7*n for n in timesIterative2]
plt.scatter(trial_number, timesIterative2, s=s, color='black',label='Iterative')

# Set a title for the plot
plt.title("Filtered Runtime of the Euclidean Algorithm Recursively vs. Iteratively in the Same While Loop")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add labels to the x and y-axes
plt.xlabel('Trial Number')
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()

# Calculate and print out the mean runtime for recursion vs iteration on each trial
# Also calculate and print out how often recursion was faster than iteration in calculation
print("Filtered Mean Runtime Different While Loops + How Often Recursion was Faster than Iteration:")
averageRecursive1 = sum(timesRecursive1)/num_trials
sys.stdout.write("Filtered Recursion Mean: %1.9fs\n" % averageRecursive1)

averageIterative1 = sum(timesIterative1)/num_trials
sys.stdout.write("Filtered Iteration Mean: %1.9fs\n" % averageIterative1)

arrayTimesRecursive1 = np.array(UFtimesRecursive1)
arrayTimesIterative1 = np.array(UFtimesIterative1)
arrayBool = arrayTimesRecursive1 < arrayTimesIterative1
sys.stdout.write("Recursion was faster than iteration at calculating the GCD: %1.0f times\n" % np.sum(arrayBool))

print("\n")

print("Filtered Mean Runtime Same While Loop + How Often Recursion was Faster than Iteration:")
averageRecursive2 = sum(timesRecursive2)/num_trials
sys.stdout.write("Filtered Recursion Mean: %1.9fs\n" % averageRecursive2)

averageIterative2 = sum(timesIterative2)/num_trials
sys.stdout.write("Filtered Iteration Mean: %1.9fs\n" % averageIterative2)

arrayTimesRecursive2 = np.array(UFtimesRecursive2)
arrayTimesIterative2 = np.array(UFtimesIterative2)
arrayBool = arrayTimesRecursive2 < arrayTimesIterative2
sys.stdout.write("Recursion was faster than iteration at calculating the GCD: %1.0f times\n" % np.sum(arrayBool))

"""# Sample Output
**Filtered Mean Runtime Different While Loops + How Often Recursion was Faster than Iteration:**

Filtered Recursion Mean: 0.000000590s

Filtered Iteration Mean: 0.000000526s

Recursion was faster than iteration at calculating the GCD: 14 times


**Filtered Mean Runtime Same While Loop + How Often Recursion was Faster than Iteration:**

Filtered Recursion Mean: 0.000000285s

Filtered Iteration Mean: 0.000000512s

Recursion was faster than iteration at calculating the GCD: 96 times
"""

# Graph the min, median, and max for the trial of recursion vs. iteration
x_axis = ["Min", "Median", "Max"]

# Determine figure size
plt.figure(figsize=(5,5))

sortedTimesRecursive1 = sorted(UFtimesRecursive1)
plt.plot(x_axis, [sortedTimesRecursive1[0], \
                  (sortedTimesRecursive1[(num_trials//2)-1] + sortedTimesRecursive1[num_trials//2])/2, sortedTimesRecursive1[-1]], \
         'r-', label="Recursive")

sortedTimesIterative1 = sorted(UFtimesIterative1)
plt.plot(x_axis, [sortedTimesIterative1[0], \
                  (sortedTimesIterative1[(num_trials//2)-1] + sortedTimesIterative1[num_trials//2])/2, sortedTimesIterative1[-1]], \
         'g-', label="Iterative")

# Set a title for the plot
plt.title("Min, Median, and Max Runtime of Recursive vs. Iterative Euclidean Algorithm in Different While Loops")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add label to the y axis
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()

# Determine figure size
plt.figure(figsize=(5,5))

sortedTimesRecursive2 = sorted(UFtimesRecursive2)
plt.plot(x_axis, [sortedTimesRecursive2[0], \
                  (sortedTimesRecursive2[(num_trials//2)-1] + sortedTimesRecursive2[num_trials//2])/2, sortedTimesRecursive2[-1]], \
         'b-', label="Recursive")

sortedTimesIterative2 = sorted(UFtimesIterative2)
plt.plot(x_axis, [sortedTimesIterative2[0], \
                  (sortedTimesIterative2[(num_trials//2)-1] + sortedTimesIterative2[num_trials//2])/2, sortedTimesIterative2[-1]], \
         'k-', label="Iterative")

# Set a title for the plot
plt.title("Min, Median, and Max Runtime of Recursive vs. Iterative Euclidean Algorithm in the Same While Loop")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add label to the y axis
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()

"""Conclusions: In Test 2, recursion is clearly superior to iteration with a mean runtime of 2.9e-7 seconds versus 5.1e-7 seconds. Recursion performed faster than iteration on 96 out of 100 trials. The results are not so clearcut for Test 1, as the means are closer and recursion only performed faster on 14 out of 100 trials. Though either method seems fine, for speed and ease in code writing, I would likely use recursion in Java.

# Python Algorithm and Analysis
"""

def gcdRecursive(a: int, b: int) -> int:
  # Calculates the greatest common divisor of a and b recursively.
  # Only positive integers should be input: Note that the gcd of a negative number m and another number n is the same as gcd(-m, n).
  if a < b:
    return gcdRecursive(b, a)
  
  mod: int = a%b
  if mod == 0 or b == 1:
    return b
  else:
    return gcdRecursive(b, mod)

def gcdIterative(a: int, b: int) -> int:
  # Calculates the greatest common divisor of a and b iteratively.
  # Only positive integers should be input: Note that the gcd of a negative number m and another number n is the same as gcd(-m, n).
  if a < b:
    temp: int = a
    a = b
    b = temp

  mod: int = 0
  while b > 1:
    mod = a%b
    a = b
    b = mod
  
  if b == 1:
    return b
  # b == 0
  else:
    return a

# Test 1: Different while loops
# Track how long the recursive method vs. the iterative method takes
pyTimesRecursive1: [float] = []
pyTimesIterative1: [float] = []

for i in range(0, num_ints, 2):
  start = time.time()
  gcdRecursive(numbers[i], numbers[i+1])
  end = time.time()
  pyTimesRecursive1.append(end-start)

for i in range(0, num_ints, 2):
  start = time.time()
  gcdIterative(numbers[i], numbers[i+1])
  end = time.time()
  pyTimesIterative1.append(end-start)

# Test 2: Same while loop
# Track how long the recursive method vs. the iterative method takes
pyTimesRecursive2: [float] = []
pyTimesIterative2: [float] = []

for i in range(0, num_ints, 2):
  start = time.time()
  gcdRecursive(numbers[i], numbers[i+1])
  end = time.time()
  pyTimesRecursive2.append(end-start)

  start = time.time()
  gcdIterative(numbers[i], numbers[i+1])
  end = time.time()
  pyTimesIterative2.append(end-start)

# Test 1
# Determine figure size
plt.figure(figsize=(20,6))

# The first parameter of scatter is the x-axis
# The second parameter of scatter is the y-axis
# Then size for the dots, s; I've made the size of each dot proportional to the data point it represents,
# so it is easier to see any patterns just by looking
# Then color
# label specifies the label for that color on the legend
s = [7e7*n for n in pyTimesRecursive1]
plt.scatter(trial_number, pyTimesRecursive1, s=s, color='red',label='Recursive')
s = [7e7*n for n in pyTimesIterative1]
plt.scatter(trial_number, pyTimesIterative1, s=s, color='green',label='Iterative')

# Set a title for the plot
plt.title("Runtime of the Euclidean Algorithm Recursively vs. Iteratively in Different While Loops")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add labels to the x and y-axes
plt.xlabel('Trial Number')
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()

# Test 2
# Determine figure size
plt.figure(figsize=(20,6))

s = [7e7*n for n in pyTimesRecursive2]
plt.scatter(trial_number, pyTimesRecursive2, s=s, color='blue',label='Recursive')
s = [7e7*n for n in pyTimesIterative2]
plt.scatter(trial_number, pyTimesIterative2, s=s, color='black',label='Iterative')

# Set a title for the plot
plt.title("Runtime of the Euclidean Algorithm Recursively vs. Iteratively in the Same While Loop")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add labels to the x and y-axes
plt.xlabel('Trial Number')
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()

# Calculate and print out the mean runtime for recursion vs iteration on each trial
# Also calculate and print out how often recursion was faster than iteration in calculation
print("Mean Runtime Different While Loops + How Often Recursion was Faster than Iteration:")
pyAverageRecursive1 = sum(pyTimesRecursive1)/num_trials
sys.stdout.write("Recursion Mean: %1.9fs\n" % pyAverageRecursive1)

pyAverageIterative1 = sum(pyTimesIterative1)/num_trials
sys.stdout.write("Iteration Mean: %1.9fs\n" % pyAverageIterative1)

pyArrayTimesRecursive1 = np.array(pyTimesRecursive1)
pyArrayTimesIterative1 = np.array(pyTimesIterative1)
arrayBool = pyArrayTimesRecursive1 < pyArrayTimesIterative1
sys.stdout.write("Recursion was faster than iteration at calculating the GCD: %1.0f times\n" % np.sum(arrayBool))

print("\n")

print("Mean Runtime Same While Loop + How Often Recursion was Faster than Iteration:")
pyAverageRecursive2 = sum(pyTimesRecursive2)/num_trials
sys.stdout.write("Recursion Mean: %1.9fs\n" % pyAverageRecursive2)

pyAverageIterative2 = sum(pyTimesIterative2)/num_trials
sys.stdout.write("Iteration Mean: %1.9fs\n" % pyAverageIterative2)

pyArrayTimesRecursive2 = np.array(pyTimesRecursive2)
pyArrayTimesIterative2 = np.array(pyTimesIterative2)
arrayBool = pyArrayTimesRecursive2 < pyArrayTimesIterative2
sys.stdout.write("Recursion was faster than iteration at calculating the GCD: %1.0f times\n" % np.sum(arrayBool))

"""# Sample Output
**Mean Runtime Different While Loops + How Often Recursion was Faster than Iteration:**

Recursion Mean: 0.000001531s

Iteration Mean: 0.000000935s

Recursion was faster than iteration at calculating the GCD: 1 times


**Mean Runtime Same While Loop + How Often Recursion was Faster than Iteration:**

Recursion Mean: 0.000002007s

Iteration Mean: 0.000001073s

Recursion was faster than iteration at calculating the GCD: 2 times
"""

# Graph the min, median, and max for the trial of recursion vs. iteration
x_axis = ["Min", "Median", "Max"]

# Determine figure size
plt.figure(figsize=(5,5))

pySortedTimesRecursive1 = sorted(pyTimesRecursive1)
plt.plot(x_axis, [pySortedTimesRecursive1[0], \
                  (pySortedTimesRecursive1[(num_trials//2)-1] + pySortedTimesRecursive1[num_trials//2])/2, pySortedTimesRecursive1[-1]], \
         'r-', label="Recursive")

pySortedTimesIterative1 = sorted(pyTimesIterative1)
plt.plot(x_axis, [pySortedTimesIterative1[0], \
                  (pySortedTimesIterative1[(num_trials//2)-1] + pySortedTimesIterative1[num_trials//2])/2, pySortedTimesIterative1[-1]], \
         'g-', label="Iterative")

# Set a title for the plot
plt.title("Min, Median, and Max Runtime of Recursive vs. Iterative Euclidean Algorithm in Different While Loops")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add label to the y axis
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()

# Determine figure size
plt.figure(figsize=(5,5))

pySortedTimesRecursive2 = sorted(pyTimesRecursive2)
plt.plot(x_axis, [pySortedTimesRecursive2[0], \
                  (pySortedTimesRecursive2[(num_trials//2)-1] + pySortedTimesRecursive2[num_trials//2])/2, pySortedTimesRecursive2[-1]], \
         'b-', label="Recursive")

pySortedTimesIterative2 = sorted(pyTimesIterative2)
plt.plot(x_axis, [pySortedTimesIterative2[0], \
                  (pySortedTimesIterative2[(num_trials//2)-1] + pySortedTimesIterative2[num_trials//2])/2, pySortedTimesIterative2[-1]], \
         'k-', label="Iterative")

# Set a title for the plot
plt.title("Min, Median, and Max Runtime of Recursive vs. Iterative Euclidean Algorithm in the Same While Loop")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add label to the y axis
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()

"""Conclusions: Though the differences in mean runtimes are small (more negligible in Test 2 than in Test 1), iteration has a slight edge over recursion in Python. This difference is more apparent when looking at the difference of maximum runtimes for recursion versus iteration in Python. Thus I would recommend using iteration rather than recursion (when it is not too troublesome) in Python.

# Java vs. Python (spoiler: Java is faster!)
"""

# Determine figure size
plt.figure(figsize=(20,6))

# Compare the fastest Java runtime to the fastest Python runtimes
# Even comparing arbitrary data from the Java and Python tests, we would find that Java is always faster than Python :)

# Use the unfiltered data just to be sure the comparison is correct
s = [10e7*n for n in UFtimesRecursive2]
plt.scatter(trial_number, UFtimesRecursive2, s=s, color='red',label='Recursive Java, Same While Loop (Test 2), Unfiltered')
s = [10e7*n for n in pyTimesIterative1]
plt.scatter(trial_number, pyTimesIterative1, s=s, color='green',label='Iterative Python, Different While Loop (Test 1)')
# Make s a constant so it is easier to see on the graph
plt.scatter(trial_number, pyTimesIterative2, s=20, color='blue',label='Iterative Python, Same While Loop (Test 2)')

# Set a title for the plot
plt.title("Java Fastest Runtime vs. Python Fastest Runtime of the Euclidean Algorithm")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add labels to the x and y-axes
plt.xlabel('Trial Number')
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()


# Again, with filtered Java data
# Determine figure size
plt.figure(figsize=(20,6))

# Filtered data to see up close
s = [10e7*n for n in timesRecursive2]
plt.scatter(trial_number, timesRecursive2, s=s, color='red',label='Recursive Java, Same While Loop (Test 2), Filtered')
s = [10e7*n for n in pyTimesIterative1]
plt.scatter(trial_number, pyTimesIterative1, s=s, color='green',label='Iterative Python, Different While Loop (Test 1)')
# Make s a constant so it is easier to see on the graph
plt.scatter(trial_number, pyTimesIterative2, s=20, color='blue',label='Iterative Python, Same While Loop (Test 2)')

# Set a title for the plot
plt.title("Java Fastest Runtime (Filtered) vs. Python Fastest Runtime of the Euclidean Algorithm")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add labels to the x and y-axes
plt.xlabel('Trial Number')
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()