# -*- coding: utf-8 -*-
"""Regex.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OImu7kcGyOpdiwVBo3QpjnnLdW-E6SDx
"""

# Commented out IPython magic to ensure Python compatibility.
"""
This code compares the runtime of regular expressions versus if statements in validating phone numbers and emails.
"""

# https://docs.python.org/3/library/re.html
# http://www.dreambank.net/regex.html
import re
import time
import matplotlib
# Allows plots to display in Google Colaboratory
# %matplotlib inline 
import matplotlib.pyplot as plt
import sys
import numpy as np

# Pattern-matching phone numbers
# Sample data/test cases:
phone_numbers = ['888-090-1234', '1234561234', '(123) 789 2833', '123.456.7890', '+1 345 1234567', '(123)4567890', '1 123 456 7890', \
                 '+1 (123)-456-7890', '11234567890', '123 4567890', '+11234567890', '123-456-7890', '(123)4567890', '(123) 4567890', \
                 '(123)-4567890', '(123).4567890', '+1 1234567890', '+1.1234567890', '+1-1234567890', '1 123 4567890', \
                 '1 123-4567890', '1 123.4567890', '1-123-4567890', '1.123.4567890', '(123).789.2833', '(123)-789-2833', \
                 '+1 345-1234567', '+1-345-1234567', '+1.345.1234567', '1 123.456.7890', '1 123-456-7890', '+1-(123)-456-7890',\
                 '+1.(123).456.7890', '+1 123 456 7890', '+1.123.456.7890', '+1-123-456-7890', '+1 123.456.7890', '+1 123-456-7890', \
                 '1 (123) 456 7890', '1 (123)-456-7890', '1-(123)-456-7890', '1.(123).456.7890', '1 (123).456.7890']
not_phone_numbers = ['1234', '(123) 456 789012', 'aed.qhj.lmno', '123-456-908i', 'ab3-456   097', '1(123))4567890', '11234567890879']
weird_phone_numbers = ['(123 456.7891', '789.123-0938', '456)231 8900', '((342))(445)(4789)', '123456 7890', '123 456-7890', \
                       '123 456.7890', '123-456.7890', '(123)456-7890', '(123)456 7890', '(123)456.7890', '1.123-4567890', \
                       '1-123 4567890', '1.123 4567890', '(123).789-2833', '(123)-789 2833', '(123).789 2833', '(123) 789-2833', \
                       '(123) 789.2833', '+1.345 1234567', '+1-345 1234567', '+1-345.1234567', '1 123 456-7890', '1 123.456-7890', \
                       '1-123 456-7890', '1.123 456-7890', '+1.(123)-456-7890', '+1 (123).456-7890', '+1-(123) 456 7890', \
                       '+1 123.456-7890', '+1 123,456,7890', '+1.123-456-7890', '1 (123) 456-7890', '1.(123) 456 7890']

# A simple regular expression to match phone numbers
phonepattern = '(\+?[0-9](\.|-| )?)?\(?[0-9]{3}\)?(\.|-| )?[0-9]{3}(\.|-| )?[0-9]{4}'
phoneprog = re.compile(phonepattern)

def regex_valid_phone_number(phone_number: str) -> bool:
  """
  Take in a string, check if it is a valid phone number using a regular expression.
  Return True if it is a valid phone number.
  """
  result = phoneprog.fullmatch(phone_number)
  if result is None:
    return False
  else:
    return True

def run_regex_phone() -> float:
  """
  Run regex_valid_phone_number() on all the sample data.
  Return how long running this method (i.e. the tests) took.
  """
  start = time.time()
  for string in phone_numbers:
    regex_valid_phone_number(string)
  for string in not_phone_numbers:
    regex_valid_phone_number(string)
  for string in weird_phone_numbers:
    regex_valid_phone_number(string)
  """
  for string in phone_numbers:
    if regex_valid_phone_number(string):
      print(string, "is a valid phone number")
    else:
      print(string, "is NOT a valid phone number")

  print('\n')

  for string in not_phone_numbers:
    if regex_valid_phone_number(string):
      print(string, "is a valid phone number")
    else:
      print(string, "is NOT a valid phone number")

  print('\n')

  for string in weird_phone_numbers:
    if regex_valid_phone_number(string):
      print(string, "is a valid phone number")
    else:
      print(string, "is NOT a valid phone number")
  """
  end = time.time()
  return end-start

run_regex_phone()
# Note that the regular expression will accept most of the "weird" (improper syntax) phone numbers

def if_statements_valid_phone_number(phone_number: str) -> bool:
  """
  Take in a string, check if it is a valid phone number using if statements.
  Return True if it is a valid phone number.
  """
  length = len(phone_number)
  # phone number must at least have 10 characters: ex. 1234567890
  if length < 10:
    #print(phone_number, "is not long enough")
    return False
  # phone number can have at most 17 characters: ex. +1 (123) 456 7890
  elif length > 17:
    #print(phone_number, "is too long")
    return False
  
  # Note: You could give more details about the specific errors by adding more if statements throughout this method
  # For example, you could create a character map and count instances of different punctuation/letters
  # and give more details about why the phone number is wrong based on that
  
  # Make sure the phone number has 10 or 11 digits
  digits = 0
  for char in phone_number:
    if char in '0123456789':
      digits += 1
  if digits < 10:
    #print(phone_number, "does not have enough digits")
    return False
  elif digits > 11:
    #print(phone_number, "has too many digits")
    return False
  
  # every character must be digits
  if length == 10:
    return True
  
  # phone number is 11234567890 or 123 4567890 (or other characters instead of the space such as - or .)
  # or the phone number is something like 123456 7890, which I would consider improper syntax, as no one would likely write a phone number like this.
  if length == 11:
    if digits == length:
      return True
    # otherwise have 10 digits
    elif phone_number[3] in ' .-':
      return True
    else:
      return False
  
  # phone number is +11234567890 or 1 1234567890 (I don't think a - or . makes sense here) 
  # or 123 456 7890 (or variations); I would not accept something like 123 456-7890, 123-456.7890, or similar
  # or the phone number has the form (123)4567890
  if length == 12:
    if digits == 11:
      if phone_number[0] == "+" or phone_number[1] == " ":
        return True
      else:
        return False
    # By here, all phone_numbers have exactly 10 digits
    elif (phone_number[0] == "(" and phone_number[4] == ")") or \
            (phone_number[3] == " " and phone_number[7] == " ") or \
            (phone_number[3] == "." and phone_number[7] == ".") or \
            (phone_number[3] == "-" and phone_number[7] == "-"):
      return True
    else:
      return False
  
  # phone number is (123) 4567890 (or variations) or +1 1234567890 (or variations)
  # or 1 123 4567890 (or variations, including 1 123-4567890, 1-123-4567890, etc.)
  # I would not accept something like 1-123 4567890
  if length == 13:
    if digits == 10:
      if phone_number[0] == "(" and phone_number[4] == ")" and phone_number[5] in " -.":
        return True
      else:
        return False
    # 11 digits
    else:
      if (phone_number[0] == "+" and phone_number[2] in " -.") or \
         (phone_number[1] == " " and phone_number[5] in " .-") or \
         (phone_number[1] == "." and phone_number[5] == ".") or \
         (phone_number[1] == "-" and phone_number[5] == "-"):
        return True
      else: 
        return False

  # phone number is (123) 456 7890 (or variations); I would not accept something like (123) 456-7890, (123)-456 7890, or similar
  # or the phone number has the form +1 123 4567890 (or variations, including +1 123-4567890 and similar)
  # or 1 123 456 7890 (or variations, including 1 123-456-7890 and similar)
  # I would not accept something like 1-123 456 7890, 1 123-456.7890, and similar
  if length == 14:
    if digits == 10:
      if phone_number[0] == "(" and phone_number[4] == ")":
        if (phone_number[5] == " " and phone_number[9] == " ") or \
           (phone_number[5] == "." and phone_number[9] == ".") or \
           (phone_number[5] == "-" and phone_number[9] == "-"):
          return True
        else:
          return False
      # End parantheses check if
      else:
        return False
    # End digits if; all phone numbers here have 11 digits
    else:
      if phone_number[0] == "+":
        if (phone_number[2] == " " and phone_number[6] in " .-") or \
           (phone_number[2] == "." and phone_number[6] == ".") or \
           (phone_number[2] == "-" and phone_number[6] == "-"):
          return True
        else:
          return False
      # if the phone number does not begin with a "+"
      elif phone_number[1] == " ":
        if (phone_number[5] == " " and phone_number[9] == " ") or \
           (phone_number[5] == "." and phone_number[9] == ".") or \
           (phone_number[5] == "-" and phone_number[9] == "-"):
           return True
        else:
          return False
      # if the second letter is not a space
      elif phone_number[1] == "-" and phone_number[5] == "-" and phone_number[9] == "-":
        return True
      # if the second letter is not a dash or a space
      elif phone_number[1] == "." and phone_number[5] == "." and phone_number[9] == ".":
        return True
      else:
        return False

  # phone number at this point must have 11 digits
  # phone number must have the form +1 123 456 7890 (or variations, including +1 123-456-7890, +1-123-456-7890, and similar)
  if length == 15:
    if digits == 11 and phone_number[0] == "+":
      if phone_number[2] == " ":
        if (phone_number[6] == " " and phone_number[10] == " ") or \
           (phone_number[6] == "." and phone_number[10] == ".") or \
           (phone_number[6] == "-" and phone_number[10] == "-"):
           return True
        else:
          return False
      # if the third letter is not a space
      elif phone_number[2] == "-" and phone_number[6] == "-" and phone_number[10] == "-":
        return True
      # if the third letter is not a dash or a space
      elif phone_number[2] == "." and phone_number[6] == "." and phone_number[10] == ".":
        return True
      else:
        return False
    else:
      return False

  # phone number must have the form 1 (123) 456 7890 (or variations, including 1 (123)-456-7890, 1-(123)-456-7890 and similar)
  if length == 16:
    if digits == 11 and phone_number[2] == "(" and phone_number[6] == ")":
      if phone_number[1] == " ":
        if (phone_number[7] == " " and phone_number[11] == " ") or \
           (phone_number[7] == "." and phone_number[11] == ".") or \
           (phone_number[7] == "-" and phone_number[11] == "-"):
           return True
        else:
          return False
      # if the second letter is not a space
      elif phone_number[1] == "-" and phone_number[7] == "-" and phone_number[11] == "-":
        return True
      # if the second letter is not a dash or a space
      elif phone_number[1] == "." and phone_number[7] == "." and phone_number[11] == ".":
        return True
      else:
        return False
    else:
      return False

  # phone number must have the form +1 (123) 456 7890 (or variations, including +1 (123)-456-7890, +1-(123)-456-7890 and similar)
  if length == 17:
    if digits == 11 and phone_number[0] == "+" and phone_number[3] == "(" and phone_number[7] == ")":
      if phone_number[2] == " ":
        if (phone_number[8] == " " and phone_number[12] == " ") or \
           (phone_number[8] == "." and phone_number[12] == ".") or \
           (phone_number[8] == "-" and phone_number[12] == "-"):
           return True
        else:
          return False
      # if the third letter is not a space
      elif phone_number[2] == "-" and phone_number[8] == "-" and phone_number[12] == "-":
        return True
      # if the third letter is not a dash or a space
      elif phone_number[2] == "." and phone_number[8] == "." and phone_number[12] == ".":
        return True
      else:
        return False
    else:
      return False

def run_if_statements_phone() -> float:
  """
  Run if_statements_valid_phone_number() on all the sample data.
  Return how long running this method (i.e. the tests) took.
  """
  start = time.time()
  for string in phone_numbers:
    if_statements_valid_phone_number(string)
  for string in not_phone_numbers:
    if_statements_valid_phone_number(string)
  for string in weird_phone_numbers:
    if_statements_valid_phone_number(string)
  """
  for string in phone_numbers:
    if if_statements_valid_phone_number(string):
      print(string, "is a valid phone number")
    else:
      print(string, "is NOT a valid phone number")

  print('\n')

  for string in not_phone_numbers:
    if if_statements_valid_phone_number(string):
      print(string, "is a valid phone number")
    else:
      print(string, "is NOT a valid phone number")

  print('\n')

  for string in weird_phone_numbers:
    if if_statements_valid_phone_number(string):
      print(string, "is a valid phone number")
    else:
      print(string, "is NOT a valid phone number")
  """
  end = time.time()
  return end-start

run_if_statements_phone()

# Pattern-matching emails
# Sample data:
emails = ['john.doe_4-3@domainsample.co.uk', 'john.doe@domainsample.net', 'JOHNDOE@DOMAINSAMPLE.COM', 'abc-d@mail.com', 'abc.def@mail.com', \
          'abc@mail.com', 'abc_def@mail.com', 'abc.def@mail.cc', 'abc.def@mail-archive.com', 'abc.def@mail.org', 'abc.def@mail.com', 'a@a.cc', \
          '123789123@123789.cc']
not_emails = ['@domainsample.com', 'johndoedomainsample.com', 'john.doe@.net', 'john.doe43@domainsample', 'abc-@mail.com', 'abc..def@mail.com', \
              '.abc@mail.com', 'abc#def@mail.com', 'abc.def@mail.c', 'abc.def@mail#archive.com', 'abc.def@mail', 'abc.def@mail..com', 'adfjkfdgadhsj' \
              'adfjkl.', 'adf_', 'asdfjkl-', 'asdfjklasd.com.org.edu', 'a', '@', 'ac@c.c', 'ajsd@-asd.cc', 'asdfj@asd-.edu', 'asdfj@asdf.123', \
              'asdfjk@adsfk.com.']
weird_emails = ['john-doe@cbs.com.org']

# About valid email formats: https://help.xmatters.com/ondemand/trial/valid_email_format.htm
# Used for more examples: https://help.returnpath.com/hc/en-us/articles/220560587-What-are-the-rules-for-email-address-syntax-
# A simple regular expression to match emails
emailpattern = '[a-zA-Z0-9]([a-zA-Z0-9]|(_|\.|-)[a-zA-Z0-9])*@[a-zA-Z0-9]([a-zA-Z0-9]|-[a-zA-Z0-9])*\.[a-zA-Z]{2,}(\.[a-zA-Z]{2,})?'
emailprog = re.compile(emailpattern)

def regex_valid_email(email: str) -> bool:
  """
  Take in a string, check if it is a valid email using a regular expression.
  Return True if it is a valid email.
  """
  result = emailprog.fullmatch(email)
  if result is None:
    return False
  else:
    return True

def run_regex_email() -> float:
  """
  Run regex_valid_email() on all the sample data.
  Return how long running this method (i.e. the tests) took.
  """
  start = time.time()
  for string in emails:
    regex_valid_email(string)
  for string in not_emails:
    regex_valid_email(string)
  for string in weird_emails:
    regex_valid_email(string)
  """
  for string in emails:
    if regex_valid_email(string):
      print(string, "is a valid email")
    else:
      print(string, "is NOT a valid email")

  print('\n')

  for string in not_emails:
    if regex_valid_email(string):
      print(string, "is a valid email")
    else:
      print(string, "is NOT a valid email")

  print('\n')

  for string in weird_emails:
    if regex_valid_email(string):
      print(string, "is a valid email")
    else:
      print(string, "is NOT a valid email")
  """
  end = time.time()
  return end-start

run_regex_email()

def if_statements_valid_email(email: str) -> bool:
  """
  Take in a string, check if it is a valid email using if statements.
  Return True if it is a valid email.
  """
  length = len(email)
  # The simplest email would be a@a.cc, so length must be at least 6
  if length < 6:
    #print(email, "is not long enough")
    return False
  # The first character of the email prefix should be a letter or number
  if email[0] not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890':
    #print(email, "does not start with a letter or number")
    return False
  
  # Check for a proper email perfix
  i = 1
  while i < length:
    if email[i] == '@':
      i += 1
      break
    elif email[i] in '_.-':
      if i+1 < length and email[i+1] in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890':
        i += 2
      else:
        #print(email, "has an underscore, period, or hyphen not followed by a letter/number")
        return False
    elif email[i] in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890':
      i += 1
    else:
      #print(email, "has an invalid character in the email prefix")
      return False
  
  if i == length:
    return False
  
  # The first character of the email domain should be a letter or number
  if email[i] not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890':
    #print(email, "has a domain that does not begin with a letter or number")
    return False
  i += 1

  # Check for a proper email domain
  while i < length:
    if email[i] == '-':
      if i+1 < length and email[i+1] in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890':
        i += 2
      else:
        #print(email, "has a hyphen not followed by a letter/number in the domain")
        return False
    elif email[i] == '.':
      i += 1
      break
    elif email[i] in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890':
      i += 1
    else:
      #print(email, "has an invalid character in the email domain")
      return False
  
  # Need at least two characters after the period
  if i == length:
    return False
  
  # Check for a proper . portion in the email domain
  another_period = False
  number_letters = 0
  while i < length:
    if email[i] == '.':
      another_period = True
      i += 1
      break
    elif email[i] in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
      number_letters += 1
      i += 1
    else:
      #print(email, "has an invalid character in the email domain, after the period")
      return False

  if number_letters < 2:
    #print(email, "does not have enough letters after the period in the domain")
    return False
  elif not another_period:
    return True
  elif i == length:
    return False

  # Check for a proper second . portion in the email domain
  number_letters = 0
  while i < length:
    if email[i] in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
      number_letters += 1
      i += 1
    else:
      #print(email, "has an invalid character in the email domain, after the second period")
      return False
  
  if number_letters < 2:
    #print(email, "does not have enough letters after the second period in the domain")
    return False
  else:
    return True

def run_if_statements_email() -> float:
  """
  Run if_statements_valid_email() on all the sample data.
  Return how long running this method (i.e. the tests) took.
  """
  start = time.time()
  for string in emails:
    if_statements_valid_email(string)
  for string in not_emails:
    if_statements_valid_email(string)
  for string in weird_emails:
    if_statements_valid_email(string)
  """
  for string in emails:
    if if_statements_valid_email(string):
      print(string, "is a valid email")
    else:
      print(string, "is NOT a valid email")

  print('\n')

  for string in not_emails:
    if if_statements_valid_email(string):
      print(string, "is a valid email")
    else:
      print(string, "is NOT a valid email")

  print('\n')

  for string in weird_emails:
    if if_statements_valid_email(string):
      print(string, "is a valid email")
    else:
      print(string, "is NOT a valid email")
  """
  end = time.time()
  return end-start

run_if_statements_email()

# Get data
# Run each run method num_trials times
num_trials = 100
# Get an array of trial numbers for graphing
trial_number = []
for i in range(1, num_trials+1):
  trial_number.append(i)

# Create arrays to keep track of the times to run on each trial, for the first test
regex_phone_times_1 = []
if_statements_phone_times_1 = []
regex_email_times_1 = []
if_statements_email_times_1 = []

# Test 1: each method runs in its own "while" loop
for i in range(num_trials):
  regex_phone_times_1.append(run_regex_phone())
for i in range(num_trials):
  if_statements_phone_times_1.append(run_if_statements_phone())
for i in range(num_trials):
  regex_email_times_1.append(run_regex_email())
for i in range(num_trials):
  if_statements_email_times_1.append(run_if_statements_email())

# Create arrays to keep track of the times to run on each trial, for the second test
regex_phone_times_2 = []
if_statements_phone_times_2 = []
regex_email_times_2 = []
if_statements_email_times_2 = []

# Test 2: each method runs in the same "while" loop
for i in range(num_trials):
  regex_phone_times_2.append(run_regex_phone())
  if_statements_phone_times_2.append(run_if_statements_phone())
  regex_email_times_2.append(run_regex_email())
  if_statements_email_times_2.append(run_if_statements_email())

# Determine figure size
plt.figure(figsize=(20,5))

# The first parameter of plot is the x-axis
# The second parameter of plot is the y-axis
# Then color
# label specifies the label for that color on the legend
plt.plot(trial_number, regex_phone_times_1, 'r-',label='Regex Phone')
plt.plot(trial_number, if_statements_phone_times_1, 'g-',label='If Statements Phone')
plt.plot(trial_number, regex_email_times_1, 'b-',label='Regex Email')
plt.plot(trial_number, if_statements_email_times_1, 'k-',label='If Statements Email')

# Set a title for the plot
plt.title("Runtime of Regular Expressions vs. If Statements in Different While Loops")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add labels to the x and y-axes
plt.xlabel('Trial Number')
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()


# Determine figure size
plt.figure(figsize=(20,5))

# Graph for Test 2
plt.plot(trial_number, regex_phone_times_2, 'r-',label='Regex Phone')
plt.plot(trial_number, if_statements_phone_times_2, 'g-',label='If Statements Phone')
plt.plot(trial_number, regex_email_times_2, 'b-',label='Regex Email')
plt.plot(trial_number, if_statements_email_times_2, 'k-',label='If Statements Email')

# Set a title for the plot
plt.title("Runtime of Regular Expressions vs. If Statements in the Same While Loop")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add labels to the x and y-axes
plt.xlabel('Trial Number')
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()

# Calculate and print out the mean runtime for each validation method on each trial
# Also calculate and print out how often regex were faster than if statements in validation
print("Mean Runtime Different While Loops + How Often Regexes Were Faster Than If Statements:")
average_regex_phone_1 = sum(regex_phone_times_1)/num_trials
sys.stdout.write("Regex Phone Mean: %1.9fs\n" % average_regex_phone_1)

average_if_statements_phone_1 = sum(if_statements_phone_times_1)/num_trials
sys.stdout.write("If Statements Phone Mean: %1.9fs\n" % average_if_statements_phone_1)

average_regex_email_1 = sum(regex_email_times_1)/num_trials
sys.stdout.write("Regex Email Mean: %1.9fs\n" % average_regex_email_1)

average_if_statements_email_1 = sum(if_statements_email_times_1)/num_trials
sys.stdout.write("If Statements Email Mean: %1.9fs\n" % average_if_statements_email_1)

array_regex_phone_times_1 = np.array(regex_phone_times_1)
array_if_statements_phone_times_1 = np.array(if_statements_phone_times_1)
array_bool_phone_1 = array_regex_phone_times_1 < array_if_statements_phone_times_1
sys.stdout.write("Regexes were faster than if statements at validating phone numbers: %1.0f times\n" % np.sum(array_bool_phone_1))

array_regex_email_times_1 = np.array(regex_email_times_1)
array_if_statements_email_times_1 = np.array(if_statements_email_times_1)
array_bool_email_1 = array_regex_email_times_1 < array_if_statements_email_times_1
sys.stdout.write("Regexes were faster than if statements at validating emails: %1.0f times\n" % np.sum(array_bool_email_1))

print("\n")

print("Mean Runtime Same While Loop + How Often Regexes Were Faster Than If Statements:")
average_regex_phone_2 = sum(regex_phone_times_2)/num_trials
sys.stdout.write("Regex Phone Mean: %1.9fs\n" % average_regex_phone_2)

average_if_statements_phone_2 = sum(if_statements_phone_times_2)/num_trials
sys.stdout.write("If Statements Phone Mean: %1.9fs\n" % average_if_statements_phone_2)

average_regex_email_2 = sum(regex_email_times_2)/num_trials
sys.stdout.write("Regex Email Mean: %1.9fs\n" % average_regex_email_2)

average_if_statements_email_2 = sum(if_statements_email_times_2)/num_trials
sys.stdout.write("If Statements Email Mean: %1.9fs\n" % average_if_statements_email_2)

array_regex_phone_times_2 = np.array(regex_phone_times_2)
array_if_statements_phone_times_2 = np.array(if_statements_phone_times_2)
array_bool_phone_2 = array_regex_phone_times_2 < array_if_statements_phone_times_2
sys.stdout.write("Regexes were faster than if statements at validating phone numbers: %1.0f times\n" % np.sum(array_bool_phone_2))

array_regex_email_times_2 = np.array(regex_email_times_2)
array_if_statements_email_times_2 = np.array(if_statements_email_times_2)
array_bool_email_2 = array_regex_email_times_2 < array_if_statements_email_times_2
sys.stdout.write("Regexes were faster than if statements at validating emails: %1.0f times\n" % np.sum(array_bool_email_2))

print("\n")

"""# Sample Output:
**Mean Runtime Different While Loops + How Often Regexes Were Faster Than If Statements:**

Regex Phone Mean: 0.000097466s

If Statements Phone Mean: 0.000123968s

Regex Email Mean: 0.000049713s

If Statements Email Mean: 0.000090201s

Regexes were faster than if statements at validating phone numbers: 88 times

Regexes were faster than if statements at validating emails: 100 times


**Mean Runtime Same While Loop + How Often Regexes Were Faster Than If Statements:**

Regex Phone Mean: 0.000068069s

If Statements Phone Mean: 0.000114470s

Regex Email Mean: 0.000050447s

If Statements Email Mean: 0.000084405s

Regexes were faster than if statements at validating phone numbers: 98 times

Regexes were faster than if statements at validating emails: 100 times
"""

# Graph the min, median, and max for the trials for each validation method
x_axis = ["Min", "Median", "Max"]

# Determine figure size
plt.figure(figsize=(5,5))

sorted_regex_phone_1 = sorted(regex_phone_times_1)
plt.plot(x_axis, [sorted_regex_phone_1[0], \
                  (sorted_regex_phone_1[(num_trials//2)-1] + sorted_regex_phone_1[num_trials//2])/2, sorted_regex_phone_1[-1]], \
         'r-', label="Regex Phone")

sorted_if_statements_phone_1 = sorted(if_statements_phone_times_1)
plt.plot(x_axis, [sorted_if_statements_phone_1[0], \
                  (sorted_if_statements_phone_1[(num_trials//2)-1] + sorted_if_statements_phone_1[num_trials//2])/2, sorted_if_statements_phone_1[-1]], \
         'g-', label="If Statements Phone")

sorted_regex_email_1 = sorted(regex_email_times_1)
plt.plot(x_axis, [sorted_regex_email_1[0], \
                  (sorted_regex_email_1[(num_trials//2)-1] + sorted_regex_email_1[num_trials//2])/2, sorted_regex_email_1[-1]], \
        'b-', label="Regex Email")

sorted_if_statements_email_1 = sorted(if_statements_email_times_1)
plt.plot(x_axis, [sorted_if_statements_email_1[0], \
                  (sorted_if_statements_email_1[(num_trials//2)-1] + sorted_if_statements_email_1[num_trials//2])/2, sorted_if_statements_email_1[-1]], \
         'k-', label="If Statements Email")

# Set a title for the plot
plt.title("Min, Median, and Max Runtime of Regular Expressions vs. If Statements in Different While Loops")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add label to the y axis
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()


# Graph for Test 2
plt.figure(figsize=(5,5))

sorted_regex_phone_2 = sorted(regex_phone_times_2)
plt.plot(x_axis, [sorted_regex_phone_2[0], \
                  (sorted_regex_phone_2[(num_trials//2)-1] + sorted_regex_phone_2[num_trials//2])/2, sorted_regex_phone_2[-1]], \
         'r-', label="Regex Phone")

sorted_if_statements_phone_2 = sorted(if_statements_phone_times_2)
plt.plot(x_axis, [sorted_if_statements_phone_2[0], \
                  (sorted_if_statements_phone_2[(num_trials//2)-1] + sorted_if_statements_phone_2[num_trials//2])/2, sorted_if_statements_phone_2[-1]], \
        'g-', label="If Statements Phone")

sorted_regex_email_2 = sorted(regex_email_times_2)
plt.plot(x_axis, [sorted_regex_email_2[0], \
                  (sorted_regex_email_2[(num_trials//2)-1] + sorted_regex_email_2[num_trials//2])/2, sorted_regex_email_2[-1]], \
        'b-', label="Regex Email")

sorted_if_statements_email_2 = sorted(if_statements_email_times_2)
plt.plot(x_axis, [sorted_if_statements_email_2[0], \
                  (sorted_if_statements_email_2[(num_trials//2)-1] + sorted_if_statements_email_2[num_trials//2])/2, sorted_if_statements_email_2[-1]], \
         'k-', label="If Statements Email")

# Set a title for the plot
plt.title("Min, Median, and Max Runtime of Regular Expressions vs. If Statements in the Same While Loop")

# Add a legend to the graph
# loc specifies the location of the legend on the graph
plt.legend(loc="upper left")

# Add label to the y axis
plt.ylabel('Time to Run in Seconds')

# Add a grid to the graph background
plt.grid()
# Show the graph
plt.show()

"""The difference in runtime speed of regular expressions versus if statements in validating phone numbers and emails in Python clearly shows regular expressions to be superior. Thus, regular expressions should generally be used when speed at runtime is valued, in addition to clarity and ease of code. Though my regular expressions have false positives, these could be eliminated by using more "or" statements in the regular expression. If statements require more code, but they give the programmer more ease in controlling exactly what type of input will be accepted and they can be used to provide more details to the user about why their input is incorrect."""
